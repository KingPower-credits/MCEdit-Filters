# This Demo describes how to use the single function generated by SchematicToScript filter
from pymclevel.schematic import MCSchematic
from pymclevel.nbt import TAG_Byte_Array
from pymclevel.box import Vector

inputs = (
  ("Places Lamp", "label"),
)

displayName = "Demo: Schematic2Script"
# Function generated by SchematicToScript. You don't have to worry about this...
def createLamp():
    e = MCSchematic(shape=(3,6,3),filename='')
    e._Blocks = [[[0,0,0],[0,0,85],[0,0,0]],[[0,0,0],[0,0,85],[0,0,0]],[[0,0,0],[0,0,85],[0,0,0]],[[0,0,0],[0,0,85],[0,0,0]],[[0,85,0],[85,89,85],[0,85,0]],[[0,53,0],[53,5,53],[0,53,0]]]
    e.root_tag['Data'] = TAG_Byte_Array([[[0,0,0],[0,0,0],[0,0,0]],[[0,0,0],[0,0,0],[0,0,0]],[[0,0,0],[0,0,0],[0,0,0]],[[0,0,0],[0,0,0],[0,0,0]],[[0,0,0],[0,0,0],[0,0,0]],[[0,2,0],[0,0,1],[0,3,0]]])
    return e
# initialise the lamp schematic
lamp = createLamp()
def placeLamp(level,dest):
    # we need a vector, so that we can move the schematic up one block
    # this will prevent the lamp from removing blocks on ground level
    vec = Vector(0,1,0)
    # copy blocks from schematic to level
    level.copyBlocksFrom(lamp,lamp.bounds,vec + dest)
def perform(level, box, options):
    # just call placeLamp
    # This is minimal thing you need to place a lamp into world:
    placeLamp(level,[box.minx,box.miny,box.minz])
    # This one is better fitted into the box coordinates.
    #placeLamp(level,[box.minx - lamp.Width + 1,box.miny,box.minz - 1])